# https://www.buildlog.net/gview/ for visualizing the gcode

import serial
import time
from typing import List
import logging

logger = logging.getLogger(__file__)


class GCodeCommands:
    @classmethod
    def circular_go_to(self, point, scale):
        # G02/G03 X12.5 Y14.7 I1.0 J2.0 F0.2;
        # X, Y – The target coordinates at the end of the movement.
        # I, J – The arc’s center point relative to X, Y.
        # F – The feedrate (Speed) at which the machine will move from the current position to the target position.

        # return f" G02 I{point[0]} J{point[1]}"
        pass

    @classmethod
    def pen_down(self):
        return "M3S030 S50"

    @classmethod
    def pen_up(self):
        return "M5"

    @classmethod
    def penetrate(self):
        return "G01  F100.0(Penetrate)"

    @classmethod
    def linear_go_to(self, point):
        return f"G01 X{point[0]} Y{point[1]}"

    @classmethod
    def fast_go_to(self, point):
        return f"G00 X{point[0]} Y{point[1]}"

    @classmethod
    def set_units_mm(self):
        return "G21 (all units in mm)"

    @classmethod
    def program_end(self):
        return "M2"




class GCodeTransformer:

    _header = [
        "%",
        "(Header)",
        "(Generated by Crayion.)",
        "M3",  # MG what is this? do we need it?
        "(Header end.)",
        GCodeCommands.pen_up(),
        GCodeCommands.set_units_mm(),
        GCodeCommands.fast_go_to([0, 0]),
    ]

    _footer = [
        "(Footer)",
        GCodeCommands.pen_up(),
        GCodeCommands.fast_go_to([0, 0]),
        GCodeCommands.program_end(),
        "(end)",
        "%",
    ]

    def __init__(self):
        self._msg = []

    def contours_to_gcode(self, contours, scale):
        for path_id, path in enumerate(contours):
            for contour_id, contour in enumerate(path):
                # cnt = contour[0].reshape(contour[0].shape[0], contour[0].shape[2])
                self._contour_to_gcode(contour, scale, f"{path_id}_{contour_id}")
        return self.msg

    def _contour_to_gcode(self, contour, scale, path_id):

        self._msg.append("")
        self._msg.append(f"(Start cutting path id: path{path_id})")
        self._msg.append("(Change tool to Default tool)")
        self._msg.append("")
        self._msg.append(GCodeCommands.fast_go_to(contour[0][0] / scale))
        self._msg.append(GCodeCommands.pen_down())
        self._msg.append(GCodeCommands.penetrate())
        for point in contour[1:]:
            self._msg.append(GCodeCommands.linear_go_to(point[0] / scale))
        self._msg.append("")
        self._msg.append(GCodeCommands.pen_up())
        self._msg.append(f"(End cutting path id: path{path_id})")
        self._msg.append("")

    @property
    def msg(self):
        return self._header + self._msg + self._footer


class GCodeSender:
    def __init__(self, port, baud_rate=115200):
        self.serial = serial.Serial(port, baud_rate)

    def send(self, msg: List[str]):

        self.serial.write("\r\n\r\n")
        time.sleep(2)  # Wait for Printrbot to initialize
        self.serial.flushInput()  # Flush startup text in serial input

        def iscomment(line):
            return False

        # Stream g-code
        for line in msg:
            if iscomment(line) or len(line) == 0:
                continue
            self.serial.write(line + "\n")  # Send g-code block
            grbl_out = self.serial.readline()  # Wait for response with carriage return

        # Close file and serial port
        self.serial.flushInput()
        # self.serial.close()
        pass


if __name__ == "__main__":

    import pickle

    with open("drawing_lines.pkl", "rb") as handle:
        contours = pickle.load(handle)

    pixel_per_mm = 20
    msg = GCodeTransformer().contours_to_gcode(contours, scale=pixel_per_mm)
    with open("test.gcode", "w") as f:
        f.write("\n".join(msg))

    # sender = GCodeSender(port='/dev/usb0')
    # sender.send(gc.msg)
