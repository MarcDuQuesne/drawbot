# https://www.buildlog.net/gview/ for visualizing the gcode

import serial
import time
from typing import List
import logging
from baffi.decorators.log_helpers import log_wrapper
from baffi.metaclasses.autodecorator import apply_to_each_function

logger = logging.getLogger(__name__)
GCODE_LOG_LEVEL = logging.DEBUG - 5
logging.addLevelName(GCODE_LOG_LEVEL, "GCODE")
logging.GCODE = GCODE_LOG_LEVEL


def debugv(self, message, *args, **kws):
    # Yes, logger takes its '*args' as 'args'.
    self._log(GCODE_LOG_LEVEL, message, args, **kws)


logging.Logger.debugv = debugv


class GCodeCommands(
    metaclass=apply_to_each_function(
        log_wrapper(post_format="{result}", level=logging.GCODE)
    )
):
    @classmethod
    def circular_go_to(self, point, scale):
        # G02/G03 X12.5 Y14.7 I1.0 J2.0 F0.2;
        # X, Y – The target coordinates at the end of the movement.
        # I, J – The arc’s center point relative to X, Y.
        # F – The feedrate (Speed) at which the machine will move from the current position to the target position.

        # return f" G02 I{point[0]} J{point[1]}"
        pass

    @classmethod
    def pen_down(self):
        return "M3S030 S50"

    @classmethod
    def pen_up(self):
        return "M5"

    @classmethod
    def penetrate(self):
        return "G01  F100.0(Penetrate)"

    @classmethod
    def linear_go_to(self, point):
        return f"G01 X{point[0]} Y{point[1]}"

    @classmethod
    def fast_go_to(self, point):
        return f"G00 X{point[0]} Y{point[1]}"

    @classmethod
    def set_units_mm(self):
        return "G21 (all units in mm)"

    @classmethod
    def program_end(self):
        return "M2"


class GCodeTransformer:

    _header = [
        "%",
        "(Header)",
        "(Generated by Crayion.)",
        "M3",  # MG what is this? do we need it?
        "(Header end.)",
        GCodeCommands.pen_up(),
        GCodeCommands.set_units_mm(),
        GCodeCommands.fast_go_to([0, 0]),
    ]

    _footer = [
        "(Footer)",
        GCodeCommands.pen_up(),
        GCodeCommands.fast_go_to([0, 0]),
        GCodeCommands.program_end(),
        "(end)",
        "%",
    ]

    def __init__(self):
        self._msg = []

    def contours_to_gcode(self, contours, scale):
        logger.debug(f"Transforming: {len(contours)} contours to gcode.")
        for path_id, path in enumerate(contours):
            for contour_id, contour in enumerate(path):
                # cnt = contour[0].reshape(contour[0].shape[0], contour[0].shape[2])
                contour_id = f"{path_id}_{contour_id}"
                self._contour_to_gcode(contour, scale, contour_id)
        return self.msg

    def _contour_to_gcode(self, contour, scale, contour_id):

        logger.debug(f"Contour id {contour_id}: {len(contour)} points.")

        self._msg.append("")
        self._msg.append(f"(Start cutting path id: path{contour_id})")
        self._msg.append("(Change tool to Default tool)")
        self._msg.append("")
        self._msg.append(GCodeCommands.fast_go_to(contour[0][0] / scale))
        self._msg.append(GCodeCommands.pen_down())
        self._msg.append(GCodeCommands.penetrate())
        for point in contour[1:]:
            self._msg.append(GCodeCommands.linear_go_to(point[0] / scale))
        self._msg.append("")
        self._msg.append(GCodeCommands.pen_up())
        self._msg.append(f"(End cutting path id: path{contour_id})")
        self._msg.append("")

    @property
    def msg(self):
        _msg = self._header + self._msg + self._footer
        logger.info(f"Length of the message: {len(_msg)}")
        return _msg


class GCodeSender:
    def __init__(self, port, baud_rate=115200):
        self.serial = serial.Serial(port, baud_rate)

    def send(self, msg: List[str]):

        self.serial.write("\r\n\r\n".encode())
        time.sleep(2)  # Wait for Printrbot to initialize
        self.serial.flushInput()  # Flush startup text in serial input

        def iscomment(line):
            return False

        # Stream g-code
        for line in msg:
            if iscomment(line) or len(line) == 0:
                continue
            self.serial.write((line + "\n").encode())  # Send g-code block
            grbl_out = self.serial.readline()  # Wait for response with carriage return

        # Close file and serial port
        self.serial.flushInput()
        # self.serial.close()
        pass


if __name__ == "__main__":

    import pickle
    import logging

    logging.basicConfig(level=logging.DEBUG)

    with open("drawing_lines.pkl", "rb") as handle:
        contours = pickle.load(handle)

    pixel_per_mm = 20
    msg = GCodeTransformer().contours_to_gcode(contours, scale=pixel_per_mm)
    with open("test.gcode", "w") as f:
        f.write("\n".join(msg))

    # sender = GCodeSender(port='/dev/usb0')
    # sender.send(gc.msg)
